15 Dynamic Programming
- 15.1 Rod Cutting
- 15.2 Matrix-chain multiplication
- 15.3 Elements of dynamic programming
- 15.4 Longest common subsequence
- 15.5 Optimal binary search trees

- (Problems)
-- 15-1 Longest simple path in a directed acyclic graph
-- 15-2 Longest palindrome subsequence
-- 15-3 Bitonic euclidean traveling-salesman problem
-- 15-4 Printing neatly
-- 15-5 Edit distance
-- 15-6 Planning a company party
-- 15-7 Viterbi algorithm
-- 15-8 Image compression by seam carving
-- 15-9 Breaking a string
-- 15-10 Planning an investment strategy
-- 15-11 Inventory planning
-- 15-12 Signing free-agent basebabll players


(15.1)
(O(2^N))
CUT-ROD(p,n)
1. if n == 0
2.	return 0
3. q = -infinity	
4. for i = 1 to n
5.	q = max( q, p[i] + CUT-ROD(p, n - i) )
6. return q

(15.1)
MEMOIZED-CUT-ROD(p,n)
1. let r[0..n] be a new array
2. for i = 0 to n	
3.	r[i] = -infinity
4. return MEMOIZED-CUT-ROD-AUX(p,n,r)

(15.1)
MEMOIZED-CUT-ROD-AUX(p,n,r)
1. if r[n] >= 0
2.	return r[n]
3. if n == 0	
4.	q = 0
5. else q = -infinity	
6. 	for i = 1 to n
7.		q = max( q, p[i] + MEMOIZED-CUT-ROD-AUX( p, n - i, r) )
8. r[n] = q
9. return q

(15.1)
BOTTOM-UP-CUT-ROD(p,n)
1. let r[0..n] be a new array
2. r[0] = 0
3. for j = 1 to n
4.	q = -infinity
5.	for i = 1 to j
6.		q = max( q, p[i] + r[j - i] )
7.	r[j] = q
8. return r[n]

(15.1)
EXTENDED-BOTTOM-UP-CUT-ROD(p,n)
1. let r[0..n] and s[0..n] be new arrays
2. r[0] = 0
3. for j = 1 to n
4.	q = -infinity
5.	for i = 1 to j
6.		if q < p[i] + r[ j - i ]
7.			q = p[i] + r[ j - i ]
8.			s[j] = i
9.	r[j] = q
10. return r and s	

(15.1)
PRINT-CUT-ROD-SOLUTION(p,n)
1. (r,s) = EXTENDED-BOTTOM-UP-CUT-ROD(p,10)
2. while n > 0
3.	print s[n]
4.	n = n - s[n]
