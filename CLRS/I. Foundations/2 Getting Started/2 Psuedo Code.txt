2 Getting Started
	
	2.1 Insertion sort
	2.2 Analyzing algorithms
	2.3 Designing algorithms
	Problems

Problems:
	
	2-1 Insertion sort on small arrays in merge sort
	2-2 Correctness of bubblesort
	2-3 Correctness of Horner's rule
	2-4 Inversions



Relevant files (within this folder): 
				* InsertionSort.h
				* MergeSort.h
				* BubbleSort.h




2.1 Insertion Sort (pp18)
	
	(book)
	INSERTION-SORT(A)
	1.	for j = 2 to A.length
	2.		key = A[j]
	3.		// Insert a[j] into the sorted sequence A[1..j-1]
	4.		i = j - 1
	5.		while ( i > 0 and A[i] > key)
	6.			A[i+1] = A[i]
	7.			i = i - 1
	8.		A[i+1] = key

	(0-based indexing)
	INSERTION-SORT(A)
	1.	for j = 1 < A.length
	2.		key = A[j]
	3.		// Insert a[j] into the sorted sequence A[1..j-1]
	4.		i = j - 1
	5.		while ( i >= 0 and A[i] > key)
	6.			A[i+1] = A[i]
	7.			i = i - 1
	8.		A[i+1] = key

	* Analysis: O(N^2) time complexity


	SELECTION-SORT(A)
	1.	n = A.length
	2.	for j = 1 to n-1
	3.		do j = smallest
	4.		for i = j+1 to n
	5.			if A[i] < A[smallest]
	6.				smallest = i
	7.			exchange A[j], A[smallest]

	* Analysis: O(N^2) time complexity

2.3 Designing Algorithms (pp31)

	MERGE(A,p,q,r)
	1.	n1 = q - p + 1
	2.	n2 = r - q
	3.	let L[1..n+1] and R[1..n2+1] be new arrays
	4.	for i = 1 to n1
	5.		L[i] = A[p+i-1]
	6.	for j = 1 to n2
	7.		R[j] = A[q+j]
	8.	L[n1+1] = infinity
	9.	R[n2+1] = infinity
	10.	i = 1
	11.	j = 1
	12.	for k = p to r
	13.		if L[i] <= R[j]
	14.			A[k] = L[i]
	15.			i = i + 1
	16.		else A[k] = R[j]
	17.			j = j + 1


	MERGE-SORT(A,p,r)
	1.	if p < r
	2.		q = floor((p+r)/2)
	3.		MERGE-SORT(A,p,q)
	4.		MERGE-SORT(A,q+1,r)
	5.		MERGE(A,p,q,r)



	BUBBLESORT(A) (pp40)
	1.	for i = 1 to A.length-1
	2.		for j = A.length downto i + 1
	3.			if A[j] < A[j-1]
	4.				exchange A[j] with A[j-1]


	ITERATIVE-BINARY-SEARCH(A,v,low,high)
	1.	while low <= high
	2.		mid = floor((low+high)/2)
	3.		if v = A[mid]
	4.			return mid
	5.		if v > A[mid]
	6.			low = mid + 1
	7.			else high = mid - 1
	8.	return NIL


	RECURSIVE-BINARY-SEARCH(A,v,low,high)
	1.	if low > high
	2.		return NIL
	3.	mid = floor((low+high)/2)
	4.	if v = A[mid]
	5.		return mid
	6.	if v > A[mid]
	7.		return RECURSIVE-BINARY-SEARCH(A,v,mid+1,high)
	8.	else return RECURSIVE-BINARY-SEARCH(A,v,low,mid-1)
	



	NAIVE-POLYNOMIAL-EVALUTION(P(x),x)
	1.	y = 0
	2.	for i = 0 to n
	3.		t = 1
	4.		for j = 1 to i
	5.			t = t * x
	6.		y = y + t * a_i
	7.	return y


	Count-Inversions(A,left,right)
	1.	inversions = 0
	2.	if left < right
	3.		mid = ⌊(left + right)/2⌋
	4.		inversions = inversions + Count-Inversions(A,left,mid)
	5.		inversions = inversions + Count-Inversions(A,mid + 1,right)
	6.		inversions = inversions + Merge-Inversions(A,left,mid,right)
	7. return inversions




	MERGE-INVERSIONS(A,left,mid,right)
	1.	n 1 = mid − left + 1
	2.	n 2 = right − mid
	3.	Let L[1..n 1 + 1] and R[1..n 2 + 1] be new arrays
	4.	for i = 1 to n 1
	5.		L[i] = A[left + i − 1]
	6.	for i = 1 to n 2
	7.		R[i] = A[mid + i]
	8.	L[n 1 + 1] = R[n 2 + 1] = ∞
	9.	i = j = 1
	10. inversions = 0
	11. counted = False
	12. for k = left to right
	13.		if counted = False and L[i] > R[j]
	14.		inversions = inversions + n 1 − i + 1
	15.		counted = True
	16.		if L[i] ≤ R[j]
	17.			A[k] = L[i]
	18.			i = i + 1
	19.		else A[k] = R[j]
	20.			j = j + 1
	21.			counted = False
	22. return inversions


	
